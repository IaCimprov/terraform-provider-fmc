import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";

// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";
import { AwsProvider } from "./.gen/providers/aws/provider";

class MyStack extends TerraformStack {
  constructor(scope: Construct, id: string) {
    super(scope, id);

    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
    new AwsProvider(this, "AWS", {
      region: "us-west-1",
    });
    const azs = new cdktf.TerraformVariable(this, "azs", {
      default: [],
      description: "AWS Availability Zones",
    });
    const fmcSize = new cdktf.TerraformVariable(this, "fmc_size", {
      default: "c5.4xlarge",
      description: "Size of the FMCv instance",
    });
    const fmcVersion = new cdktf.TerraformVariable(this, "fmc_version", {
      default: "fmcv-7.0.0",
      description: "Version of the FMCv",
    });
    const hostname = new cdktf.TerraformVariable(this, "hostname", {
      default: "fmc",
      description: "FMCv OS hostname",
    });
    const igwId = new cdktf.TerraformVariable(this, "igw_id", {
      default: "",
      description: "Existing Internet Gateway ID",
    });
    const instances = new cdktf.TerraformVariable(this, "instances", {
      default: 1,
      description: "Number of FMCv instances",
    });
    const keyName = new cdktf.TerraformVariable(this, "key_name", {
      description: "AWS EC2 Key",
    });
    const nameTagPrefix = new cdktf.TerraformVariable(this, "name_tag_prefix", {
      default: "FMCv",
      description: "Prefix for the 'Name' tag of the resources",
    });
    const password = new cdktf.TerraformVariable(this, "password", {
      default: "P@$w0rd1234",
      description: "Password for FMCv",
      sensitive: true,
    });
    const subnetSize = new cdktf.TerraformVariable(this, "subnet_size", {
      default: 24,
      description: "Size of Management subnet",
    });
    const subnets = new cdktf.TerraformVariable(this, "subnets", {
      default: [],
      description: "mgmt subnets",
    });
    const vpcCidr = new cdktf.TerraformVariable(this, "vpc_cidr", {
      default: "10.0.0.0/16",
      description: "VPC CIDR",
    });
    const vpcId = new cdktf.TerraformVariable(this, "vpc_id", {
      default: "",
      description: "Existing VPC ID",
    });
    const vpcName = new cdktf.TerraformVariable(this, "vpc_name", {
      default: "Cisco-FMCv",
      description: "VPC Name",
    });
    const awsEipFmcMgmtEip = new aws.eip.Eip(this, "fmc-mgmt-eip", {
      tags: {
        Name: `\${${nameTagPrefix.value}} Management IP%{if ${instances.value} > 1} \${count.index}%{endif}`,
      },
      vpc: true,
    });

    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsEipFmcMgmtEip.addOverride("count", instances.value);
    const awsVpcFmcVpc = new aws.vpc.Vpc(this, "fmc_vpc", {
      cidrBlock: vpcCidr.value,
      enableClassiclink: false,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      instanceTenancy: "default",
      tags: {
        Name: vpcName.value,
      },
    });
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsVpcFmcVpc.addOverride("count", `\${${vpcId.value} != "" ? 0 : 1}`);
    const dataAwsAmiFmcv = new aws.dataAwsAmi.DataAwsAmi(this, "fmcv", {
      filter: [
        {
          name: "name",
          values: [`\${${fmcVersion.value}}*`],
        },
        {
          name: "product-code",
          values: ["bhx85r4r91ls2uwl69ajm9v1b"],
        },
        {
          name: "virtualization-type",
          values: ["hvm"],
        },
      ],
      owners: ["aws-marketplace"],
    });
    const dataAwsAvailabilityZonesAvailable =
      new aws.dataAwsAvailabilityZones.DataAwsAvailabilityZones(
        this,
        "available",
        {
          filter: [
            {
              name: "opt-in-status",
              values: ["opt-in-not-required"],
            },
          ],
        }
      );
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    dataAwsAvailabilityZonesAvailable.addOverride(
      "count",
      `\${length(${azs.value}) > 0 ? 0 : 1}`
    );
    const dataAwsVpcSelected = new aws.dataAwsVpc.DataAwsVpc(this, "selected", {
      id: vpcId.value,
    });
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    dataAwsVpcSelected.addOverride("count", `\${${vpcId.value} == "" ? 0 : 1}`);
    const localAzs = `\${length(${azs.value}) > 0 ? ${azs.value} : ${dataAwsAvailabilityZonesAvailable.fqn}[0].names}`;
    const localVpcCidr = `\${${vpcId.value} != "" ? ${dataAwsVpcSelected.fqn}[0].cidr_block : ${vpcCidr.value}}`;
    new cdktf.TerraformOutput(this, "FMCv_EIPs", {
      value: `\${${awsEipFmcMgmtEip.fqn}[*].public_ip}`,
    });
    const awsInternetGatewayIntGw = new aws.internetGateway.InternetGateway(
      this,
      "int_gw",
      {
        tags: {
          Name: `\${${nameTagPrefix.value}} Internet Gateway`,
        },
        vpcId: `\${${vpcId.value} != "" ? ${vpcId.value} : ${awsVpcFmcVpc.fqn}[0].id}`,
      }
    );
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsInternetGatewayIntGw.addOverride(
      "count",
      `\${${igwId.value} != "" ? 0 : 1}`
    );
    const awsRouteTableFmcMgmtRoute = new aws.routeTable.RouteTable(
      this,
      "fmc_mgmt_route",
      {
        tags: {
          Name: `\${${nameTagPrefix.value}} Mgmt network Routing table`,
        },
        vpcId: `\${${vpcId.value} != "" ? ${vpcId.value} : ${awsVpcFmcVpc.fqn}[0].id}`,
      }
    );
    const awsSecurityGroupAllowAll = new aws.securityGroup.SecurityGroup(
      this,
      "allow_all",
      {
        description: "Allow all traffic",
        egress: [
          {
            cidrBlocks: ["0.0.0.0/0"],
            fromPort: 0,
            protocol: "-1",
            toPort: 0,
          },
        ],
        ingress: [
          {
            cidrBlocks: ["0.0.0.0/0"],
            fromPort: 0,
            protocol: "-1",
            toPort: 0,
          },
        ],
        name: "Allow All",
        tags: {
          Name: `\${${nameTagPrefix.value}} Public Allow`,
        },
        vpcId: `\${${vpcId.value} != "" ? ${vpcId.value} : ${awsVpcFmcVpc.fqn}[0].id}`,
      }
    );
    const azDistribution = `\${chunklist(sort(flatten(chunklist(setproduct(range(${instances.value}), ${localAzs}), ${instances.value})[0])), ${instances.value})[1]}`;
    const subnetNewbits = `\${${subnetSize.value} - tonumber(split("/", ${localVpcCidr})[1])}`;
    new aws.route.Route(this, "ext_default_route", {
      destinationCidrBlock: "0.0.0.0/0",
      gatewayId: `\${${igwId.value} != "" ? ${igwId.value} : ${awsInternetGatewayIntGw.fqn}[0].id}`,
      routeTableId: awsRouteTableFmcMgmtRoute.id,
    });
    const azDistinct = `\${distinct(${azDistribution})}`;
    const awsSubnetMgmt = new aws.subnet.Subnet(this, "mgmt", {
      availabilityZone: `\${${azDistinct}[count.index]}`,
      cidrBlock: `\${length(${subnets.value}) == 0 ? cidrsubnet(${localVpcCidr}, ${subnetNewbits}, count.index) : ${subnets.value}[count.index]}`,
      tags: {
        Name: `\${${nameTagPrefix.value}} Mgmt subnet %{if length(${azDistinct}) > 1}\${count.index}%{endif}`,
      },
      vpcId: `\${${vpcId.value} != "" ? ${vpcId.value} : ${awsVpcFmcVpc.fqn}[0].id}`,
    });
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsSubnetMgmt.addOverride("count", `\${length(${azDistinct})}`);
    const awsNetworkInterfaceMgmt = new aws.networkInterface.NetworkInterface(
      this,
      "mgmt_25",
      {
        description: `%{if length(${azDistinct}) > 1}\${${azDistribution}[count.index]}-%{endif}fmc-mgmt`,
        sourceDestCheck: false,
        subnetId: `\${${awsSubnetMgmt.fqn}[index(${azDistinct}, ${azDistribution}[count.index])].id}`,
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsNetworkInterfaceMgmt.overrideLogicalId("mgmt");
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsNetworkInterfaceMgmt.addOverride("count", instances.value);
    const awsNetworkInterfaceSgAttachmentFmcMgmtAttachment =
      new aws.networkInterfaceSgAttachment.NetworkInterfaceSgAttachment(
        this,
        "fmc_mgmt_attachment",
        {
          networkInterfaceId: `\${${awsNetworkInterfaceMgmt.fqn}[count.index].id}`,
          securityGroupId: awsSecurityGroupAllowAll.id,
        }
      );
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsNetworkInterfaceSgAttachmentFmcMgmtAttachment.addOverride(
      "count",
      instances.value
    );
    const awsRouteTableAssociationMgmtAssociation =
      new aws.routeTableAssociation.RouteTableAssociation(
        this,
        "mgmt_association",
        {
          routeTableId: awsRouteTableFmcMgmtRoute.id,
          subnetId: `\${${awsSubnetMgmt.fqn}[count.index].id}`,
        }
      );
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsRouteTableAssociationMgmtAssociation.addOverride(
      "count",
      `\${length(${azDistinct})}`
    );
    const awsEipAssociationFmcMgmtIpAssocation =
      new aws.eipAssociation.EipAssociation(this, "fmc-mgmt-ip-assocation", {
        allocationId: `\${${awsEipFmcMgmtEip.fqn}[count.index].id}`,
        networkInterfaceId: `\${${awsNetworkInterfaceMgmt.fqn}[count.index].id}`,
      });
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsEipAssociationFmcMgmtIpAssocation.addOverride("count", instances.value);
    const awsInstanceFmcv = new aws.instance.Instance(this, "fmcv_29", {
      ami: dataAwsAmiFmcv.id,
      instanceType: fmcSize.value,
      keyName: keyName.value,
      networkInterface: [
        {
          deviceIndex: 0,
          networkInterfaceId: `\${${awsNetworkInterfaceMgmt.fqn}[count.index].id}`,
        },
      ],
      tags: {
        Name: `Cisco \${${nameTagPrefix.value}}%{if ${instances.value} > 1} \${count.index}%{endif}`,
      },
      userData: `#FMC
{
"AdminPassword": "\${${password.value}}",
"Hostname":      "\${${hostname.value}}%{if ${instances.value} > 1}-\${count.index}%{endif}",
}
`,
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    awsInstanceFmcv.overrideLogicalId("fmcv");
    /*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
    awsInstanceFmcv.addOverride("count", instances.value);
  }
}

const app = new App();
new MyStack(app, "cc");
app.synth();
